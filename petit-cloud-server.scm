(import (chezscheme))
(import (letloop blake3))
(import (letloop byter))
(import (letloop bytevector))
(import (letloop flow entangle))
(import (letloop html))
(import (letloop http))
(import (letloop json))
(import (letloop match))
(import (letloop www))
(import (only (letloop foundationdb entangle) make-fdb))
(import (only (petit-cloud base) call-with-database-transaction database-query database-set! database-clear!))


(define pk
  (lambda args
    (display ";; " (current-error-port))
    (write args (current-error-port))
    (newline (current-error-port))
    (flush-output-port (current-error-port))
    (car (reverse args))))

(define call-with-input-from-string
  (lambda (string proc)
    (define port (open-input-string string))
    (call-with-values (lambda () (proc port))
      (lambda args
        (close-port port)
        (apply values args)))))

(define read*
  (lambda (string)
    (call-with-input-from-string string read)))

(define call-with-output-to-string
  (lambda (proc)
    (define port (open-output-string))
    (proc port)
    (let ((out (get-output-string port)))
      (close-port port)
      out)))

(define write*
  (lambda (object)
    (call-with-output-to-string
     (lambda (port)
       (write object port)))))

(define generator->string
  (lambda (g)
    (let loop ((out '()))
      (let ((object (g)))
        (if (eof-object? object)
            (utf8->string (apply bytevector-append (reverse out)))
            (loop (cons object out)))))))

(define headers-host-ref
  (lambda (headers)
    (cdr (or
          (assq 'x-forwarded-host headers)
          (assq 'host headers)
          (cons #f #f)))))

(define http-read*
  (lambda (read)

    ;; TODO: clean up?

    (define http-read-bytes
      (lambda (read)
        ;; Read generated BYTEVECTOR, and generate one by one BYTE
        (define index 0)
        (define bv (bytevector))

        (define moar
          (lambda ()
            (set! bv (read))
            (set! index 0)))

        (define init
          (lambda ()
            (moar)
            (set! continue yield)
            (yield)))

        (define continue init)

        (define yield
          (lambda ()
            (cond
             #;((fxzero? (bytevector-length bv)) (eof-object))
             ((fx=? (bytevector-length bv) index) (init))
             (else (let ((byte (bytevector-u8-ref bv index)))
                     (set! index (fx+ index 1))
                     byte)))))

        (lambda ()
          (continue))))

    (call-with-values (lambda () (http-request-read (http-read-bytes read)))
      (lambda (method uri version headers body)
        #;(pk 'request method uri version headers)
        (call-with-values (lambda () (www-uri-read uri))
          (lambda (path query fragment)
            (values method
                    path
                    query
                    fragment
                    headers
                    body)))))))

(define make-petit-cloud-http-reader
  (lambda (read)
    (lambda ()
      (http-read* read))))

(define html-write*
  (lambda (sxml)

    (define make-string-accumulator
      (lambda ()
        (let ((out '()))
          (lambda (object)
            (if (eof-object? object)
                (apply string-append (reverse out))
                (set! out (cons object out)))))))

    (define out (make-string-accumulator))
    (html-write sxml out)
    (out (eof-object))))

(define http-write*
  (lambda (write code headers body)
    (http-response-write write
                         "HTTP/1.1"
                         code
                         ""
                         headers
                         body)))

(define make-petit-cloud-http-writer
  (lambda (write)
    (lambda (code headers body)
      (http-response-write write "HTTP/1.1"
                           code
                           ""
                           headers
                           body))))

(define petit-cloud-deployment?
  (lambda (method path)
    (and (eq? method 'PUT)
         (equal? path '("_" "api" "v0")))))

(define make-petit-cloud-init-application
  (lambda ()
    (lambda (write method path query fragment headers body)
      ;; TODO: display instruction to update petit-cloud application
      ;; server with hello.scm
      (write 200
             (list (cons 'content-type "text/plain"))
             (string->utf8 "hello world\n")))))

(define petit-cloud-current-application
  (make-parameter (make-petit-cloud-init-application)))

(define make-petit-cloud-application
  (lambda (code)

    (define secure
      (lambda (exp)
        (match exp
          ;; TODO: error to report to the user
          ((import ,_ ...) (raise 'insecure))
          ((,(e) ...) (void)))))

    (define massage
      (lambda (exp)
        (match exp
          ((library ,name
             (export main)
             (import (petit-cloud base))
             ,exp ...)
           (for-each secure exp)
           `(module (main)
              ,exp ...)))))

    ;; TODO: rename import and module
    (define myenv
      (let ((env (environment '(only (chezscheme) import module)
                              '(petit-cloud base))))
        (copy-environment env #t)))

    ;; TODO: handle unreadable, error to report to the user
    (define target (massage code))
    (define i (eval target myenv))
    (define main (eval 'main myenv))
    main))

(define petit-cloud-secret
  (lambda ()
    (call-with-database-transaction
     (lambda (tx)
       (database-query tx (bytevector))))))

(define petit-cloud-secret!
  (lambda (secret)
    (call-with-database-transaction
     (lambda (tx)
       (database-set! tx (bytevector) (blake3 secret))))))

(define petit-cloud-deploy?
  (lambda (secret)
    ;; TODO: use constant time comparison, or better argon2
    (equal? (petit-cloud-secret) (blake3 secret))))

(define petit-cloud-deploy!
  (lambda (write code)
    (petit-cloud-current-application (make-petit-cloud-application code))
    (write 201
           (list (cons 'content-type "application/scheme"))
           (string->utf8 (write* '(ok))))))

(define client-accept
  (lambda (read write close)
    (guard (ex (else (pk 'oops 'application
                         (apply format #f
                                (condition-message ex)
                                (condition-irritants ex)))
                     (write 500 '() (bytevector))))
      (define-values (method path query fragment headers body) (read))
      (if (petit-cloud-deployment? method path)
          (let ((in (read* (generator->string body))))
            (unless (petit-cloud-secret)
              (petit-cloud-secret! (cadr in)))
            (if (petit-cloud-deploy? (cadr in))
                (petit-cloud-deploy! write (caddr in))
                (write 401
                       (list (cons 'content-type "application/scheme"))
                       (string->utf8 (write* '(invalid))))))
          (let ((application (petit-cloud-current-application)))
            (application write method path query fragment headers body))))))

(define petit-cloud-http-serve
  (lambda (ip port k)
    (define fdb (make-fdb))
    (make-entangle)
    (entangle-spawn
     (lambda ()
       (call-with-values (lambda () (entangle-tcp-serve ip port))
         (lambda (accept close)
           (format #t "HTTP server running at http://~a:~a\n" ip port)
           (let loop ()
             (call-with-values accept
               (lambda (read write close)
                 (entangle-spawn
                  (lambda ()
                    (k (make-petit-cloud-http-reader read)
                       (make-petit-cloud-http-writer write)
                       close)
                    (close)))))
             (loop))))))
    (entangle-run)))

;; TODO: add usage
(petit-cloud-http-serve (cadr (command-line))
                        (string->number (caddr (command-line)))
                        client-accept)
